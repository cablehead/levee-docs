<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <link rel="shortcut icon" href="./img/favicon.ico">

    <title>Levee Documentation</title>

    <link href="./css/bootstrap-custom.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="./css/base.css" rel="stylesheet">
    <link href="./css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body class="homepage" >

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href=".">Levee Documentation</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                
                    <li>
                        <a href="https://github.com/imgix/levee">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="first-level active"><a href="#core-hub">Core: Hub</a></li>
        
            <li class="second-level"><a href="#coroutines">Coroutines</a></li>
            
        
            <li class="second-level"><a href="#io">IO</a></li>
            
        
            <li class="second-level"><a href="#network">Network</a></li>
            
        
    
        <li class="first-level "><a href="#objects-io">Objects: IO</a></li>
        
            <li class="second-level"><a href="#ior">io.R</a></li>
            
        
            <li class="second-level"><a href="#iow">io.W</a></li>
            
        
            <li class="second-level"><a href="#iostream">io.Stream</a></li>
            
        
    
        <li class="first-level "><a href="#misc-tls-options">Misc: TLS Options</a></li>
        
    
        <li class="first-level "><a href="#requirelevee95">require("levee")._</a></li>
        
            <li class="second-level"><a href="#network_1">Network</a></li>
            
        
            <li class="second-level"><a href="#file-system">File System</a></li>
            
        
            <li class="second-level"><a href="#stat">Stat</a></li>
            
        
    
        <li class="first-level "><a href="#requireleveed">require("levee").d</a></li>
        
            <li class="second-level"><a href="#dbuffer">d.Buffer</a></li>
            
        
            <li class="second-level"><a href="#diovec">d.Iovec</a></li>
            
        
    
        <li class="first-level "><a href="#requireleveep">require("levee").p</a></li>
        
            <li class="second-level"><a href="#pjson">p.json</a></li>
            
        
    
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="core-hub">Core: Hub</h1>
<h2 id="coroutines">Coroutines</h2>
<dl>
<dt>h:sleep(ms)</dt>
<dd>Suspends the current green thread until at least <code>ms</code> milliseconds in the
  future, when it will be resumed.</dd>
<dt>h:spawn(f)</dt>
<dd>Spawns and queues to run the callable <code>f</code> as a new green thread. The current
  thread will yield to be resumed after 1 tick of the event loop.</dd>
<dt>h:spawn_later(ms, f)</dt>
<dd>Schedules the callable <code>f</code> to run at least <code>ms</code> milliseconds in the future,
  in a new green thread.</dd>
</dl>
<pre><code class="lua">local h = require(&quot;levee&quot;).Hub()

h:spawn(function()
  while true do
    print(&quot;tick&quot;)
    h:sleep(1000)
  end
end)

h:sleep(500)

while true do
  print(&quot;tock&quot;)
  h:sleep(1000)
end
</code></pre>

<h2 id="io">IO</h2>
<dl>
<dt>h.io:stdin()</dt>
<dd>Returns an <a href="#ior">io.R</a> object to work with this processes stdin</dd>
</dl>
<pre><code class="lua">local h = require(&quot;levee&quot;).Hub()

local stdin = h.io:stdio()
local stream = stdin:stream()

while true do
  local err, line = stream:line()
  if err then break end
  print(line)
end
</code></pre>

<dl>
<dt>h.io:stdout()</dt>
<dd>Returns an <a href="#w">io.W</a> object to work with this processes stdout</dd>
</dl>
<h2 id="network">Network</h2>
<dl>
<dt>h.stream:dial(endpoint|options)</dt>
<dd>Establishes a streamed network connection based on the supplied <code>endpoint</code>
  string or <code>options</code> (<code>endpoint</code> TBD). Returns <code>err</code>, <a href="#ior">io.RW</a></dd>
</dl>
<p>Options are:</p>
<ul>
<li>
<p><code>local</code>: path to unix domain socket (TBD) <em>OR</em></p>
</li>
<li>
<p><code>port</code>: port to connect to</p>
</li>
<li>
<p><code>host</code>: host to connect to (default: localhost)</p>
</li>
<li>
<p><code>timeout</code>: timeout for reads and writes on this connection</p>
</li>
<li>
<p><code>connect_timeout</code>: timeout to apply to connection</p>
</li>
<li>
<p><code>tls</code>: upgrade this connection to use tls. Note <code>timeout</code> also applies to the
  tls handshake. The value is a table of <a href="#misc-tls-options">TLS Options</a>.</p>
</li>
</ul>
<dl>
<dt>h.stream:listen(endpoint|options)</dt>
<dd>Binds to <code>endpoint</code> string or as specified with <code>options</code> and listens for
  streamed connections. Returns <code>err</code>, <a href="#TDB">Recver</a>. The Recver yields <code>err</code>,
  <a href="#ior">io.RW</a> for each accepted connection.</dd>
</dl>
<p>Options are:</p>
<ul>
<li>
<p><code>local</code>: path to unix domain socket (TBD) <em>OR</em></p>
</li>
<li>
<p><code>port</code>: port to bind to (default: 0)</p>
</li>
<li>
<p><code>host</code>: host to bind to (default: localhost)</p>
</li>
<li>
<p><code>backlog</code>: the maximum length for the queue of pending connections (default:
  256)</p>
</li>
<li>
<p><code>timeout</code>: sets the read / write timeout for accepted connections</p>
</li>
<li>
<p><code>tls</code>: upgrade accepted connections to use tls. Note <code>timeout</code> also
  applies to the tls handshake. The value is a table of <a href="#misc-tls-options">TLS
  Options</a>.</p>
</li>
</ul>
<pre><code class="lua">local h = require(&quot;levee&quot;).Hub()

-- a basic echo server
local err, serve = h.stream:listen({port=9000})

while true do
    local err, conn = serve:recv()
    if err then break end
    h:spawn(function()
        local buf = levee.d.Buffer(4096)
        conn:readinto(buf:tail())
        conn:write(buf:value())
        conn:close()
    end)
end
</code></pre>

<h1 id="objects-io">Objects: IO</h1>
<h2 id="ior">io.R</h2>
<dl>
<dt>r:read(char*, len)</dt>
<dd>Reads up to <code>len</code> bytes into <code>char*</code>. Returns <code>err</code>, <code>n</code> where <code>n</code> is the
  number of bytes actually read</dd>
<dt>r:readn(char*, n, [len])</dt>
<dd>Reads <em>at least</em> <code>n</code> bytes into <code>char*</code>, but <em>no more</em> then <code>len</code>. <code>len</code>
  defaults to <code>n</code>. Returns <code>err</code>, <code>n</code> where <code>n</code> is the number of bytes actually
  read</dd>
<dt>r:readinto(buf, n)</dt>
<dd>Reads <em>at least</em> <code>n</code> bytes into <a href="#dbuffer">buf</a>. Handles ensuring the <code>buf</code>
  is large enough to accommodate <code>n</code> and bumps the contents marker. Returns
  <code>err</code>.</dd>
<dt>r:stream()</dt>
<dd>Returns an <a href="#iostream">io.Stream</a></dd>
</dl>
<h2 id="iow">io.W</h2>
<dl>
<dt>w:write(buf, [len])</dt>
<dd>Writes <code>buf</code>. <code>buf</code> can either be a <code>char *</code> or a <code>string</code>. <code>len</code> defaults to
  <code>#buf</code>.  Returns <code>err</code>.</dd>
</dl>
<h2 id="iostream">io.Stream</h2>
<p>A stream is a combination of an <a href="#ior">io.R</a> and a <a href="#dbuffer">d.Buffer</a>.</p>
<dl>
<dt>stream:readin([n])</dt>
<dd>Reads additional bytes into this stream's buffer. <code>n</code> is optional. If
  supplied this call will block until <em>at least</em> <code>n</code> bytes are available in the
  buffer. If that many bytes are already available, it will return immediately.
  If <code>n</code> is not supplied this call will block until one successful read has
  been made.</dd>
</dl>
<h1 id="misc-tls-options">Misc: TLS Options</h1>
<pre><code>  Certificate Authority:
    ca = BYTES            # root certificates from string
    ca_path = DIRECTORY   # directory searched for root certificates
    ca_file = FILE        # file containing the root certificates
  Certificate:
    cert = BYTES          # public certificate from string
    cert_file = FILE      # file containing the public certificate
  Key:
    key = BYTES           # private key from string
    key_file = FILE       # file containing the private key
  Ciphers:
    ciphers = &quot;secure&quot;    # use the secure ciphers only (default)
    ciphers = &quot;compat&quot;    # OpenSSL compatibility
    ciphers = &quot;legacy&quot;    # (not documented)
    ciphers = &quot;insecure&quot;  # all ciphers available
    ciphers = &quot;all&quot;       # same as &quot;insecure&quot;
    ciphers = STRING      # see CIPHERS section of openssl(1)
  DHE Params:
    dheparams = STRING    # (not documented)
  ECDHE Curve:
    ecdhecurve = STRING   # (not documented)
  Protocols:
    protocols = &quot;TLSv1.0&quot; # only TLSv1.0
    protocols = &quot;TLSv1.1&quot; # only TLSv1.1
    protocols = &quot;TLSv1.2&quot; # only TLSv1.2
    protocols = &quot;ALL&quot;     # all supported protocols
    protocols = &quot;DEFAULT&quot; # currently TLSv1.2
    protocols = LIST      # any combination of the above strings
  Verfiy Depth:
    verify_depth = NUMBER # limit verification depth (?)
  Server:
    server = {
      prefer_ciphers = &quot;server&quot;  # prefer client cipher list (less secure)
      prefer_ciphers = &quot;client&quot;  # prefer server cipher list (more secure, default)
      verify_client = true       # require client to send certificate
      verify_client = &quot;optional&quot; # enable client to send certificate
    }
  Insecure:
    insecure = {
      verify_cert = false        # disable certificate verification
      verify_name = false        # disable server name verification for client
      verify_time = false        # disable validity checking of certificates
    }
</code></pre>

<h1 id="requirelevee95">require("levee")._</h1>
<p><strong>_</strong> is for utilities</p>
<h2 id="network_1">Network</h2>
<dl>
<dt>_.endpoint_in(host, port)</dt>
<dd>Returns <code>ep</code> an IPV4 <a href="#endpoint">Endpoint</a> for the given <code>host</code> and <code>port</code>.</dd>
<dt>_.sendto(no, who, buf, len)</dt>
<dd>Sends <code>buf</code>, <code>len</code> over file descriptor <code>no</code> to <a href="#endpoint">Endpoint</a> <code>who</code>. Returns
  <code>err</code>, <code>n</code>, where <code>n</code> is the number of characters sent on success.</dd>
<dt>_.recvfrom(no, buf, len)</dt>
<dd>Receives from file descriptor <code>no</code> into <code>buf</code>, <code>len</code>. Returns <code>err</code>, <code>who</code>,
  <code>n</code> where <code>who</code> is an <a href="#endpoint">Endpoint</a> object of the sender and <code>n</code> is
  the number of bytes received.</dd>
</dl>
<h2 id="file-system">File System</h2>
<dl>
<dt>_.stat(path)</dt>
<dd>Returns <code>err</code>, <code>statinfo</code> for the file pointed to by path where <code>statinfo</code> is
  a <a href="#stat">Stat</a> object.</dd>
</dl>
<h2 id="stat">Stat</h2>
<dl>
<dt>stat:is_reg()</dt>
<dd>Returns <code>true</code> if this is a regular file.</dd>
<dt>stat:is_dir()</dt>
<dd>Returns <code>true</code> if this is a directory.</dd>
</dl>
<h1 id="requireleveed">require("levee").d</h1>
<p><strong>d</strong> is for data structure thingies</p>
<h2 id="dbuffer">d.Buffer</h2>
<p>A <code>Buffer</code> is designed to be a reusable scratch pad of memory. It can grow
dynamically if it's initial sizing is too small, but eventually you usually
want the size of the buffer to reach a steady state. It's the work horse data
structure of the Levee library. It is used, for example, to create streaming
protocol parsers. The parser reads bytes into the <code>Buffer</code> until the next token
in the protocol is reached and the parser can then yield the next portion of
the protocol and then <code>:trim</code> the <code>Buffer</code> to reset the memory allocation for
reuse.</p>
<dl>
<dt>d.Buffer([bytes])</dt>
<dd>allocates and returns a new <code>buf</code>. <code>bytes</code> is a sizing hint for the initial
  allocation of memory for this <code>Buffer</code></dd>
<dt>buf:ensure([bytes])</dt>
<dd>ensures the <code>Buffer</code> has <em>at least</em> <code>bytes</code> available of allocated space, in
  addition to what's currently in use.</dd>
<dt>buf:write(buf, [len])</dt>
<dd>copies <code>buf</code> into the tail of the <code>Buffer</code>. <code>buf</code> can either be a <code>char *</code> or a
  <code>string</code>. <code>len</code> defaults to <code>#buf</code>. Write ensures the buffer is large enough to
  hold the write and bumps the <code>Buffer</code>'s content marker</dd>
<dt>buf:value([[off], len])</dt>
<dd>If <code>len</code> is supplied it should be less than the current length of the
  <code>Buffer</code>. <code>len</code> defaults to the entire <code>Buffer</code>'s contents. The optional
  <code>off</code> offsets the returned <code>char *</code> from the beginning of the <code>Buffer</code>'s
  contents.  Returns <code>char*</code>, <code>len</code></dd>
<dt>buf:tail()</dt>
<dd>returns <code>char*</code>, <code>len</code> to the tail of the allocated <code>Buffer</code> that's not
  currently in use</dd>
<dt>buf:bump(len)</dt>
<dd>moves the marker for in use bytes by <code>len</code></dd>
<dt>buf:trim([len])</dt>
<dd>marks <code>len</code> bytes of the <code>Buffer</code> as available for reuse. If <code>len</code> is not
  supplied to entire <code>Buffer</code> is marked. Returns <code>n</code>, the number of bytes
  trimmed</dd>
</dl>
<pre><code class="lua">local buf = d.Buffer()

buf:ensure(3)
ffi.copy(buf:tail(), &quot;foo&quot;)
buf:bump(3)
ffi.string(buf:value())  -- &quot;foo&quot;

buf:write(&quot;bar&quot;)
ffi.string(buf:value())  -- &quot;foobar&quot;

ffi.string(buf:value(3))  -- &quot;foo&quot;
ffi.string(buf:value(3, 1))  -- &quot;b&quot;

buf:trim()
ffi.string(buf:value())  -- &quot;&quot;
</code></pre>

<h2 id="diovec">d.Iovec</h2>
<dl>
<dt>d.Iovec([size])</dt>
<dd><em>todo</em></dd>
</dl>
<h1 id="requireleveep">require("levee").p</h1>
<p><strong>p</strong> is for parsing / protocol jobbies</p>
<h2 id="pjson">p.json</h2>
<dl>
<dt>p.json.decode(buf, len)</dt>
<dd>Decode the JSON compliant string <code>buf</code>, <code>len</code>. <code>buf</code> can be a Lua string.
  Returns <code>err</code>, <code>data</code>.</dd>
</dl>
<pre><code class="lua">local p = require(&quot;levee&quot;).p

local err, data = p.json.decode([[{&quot;foo&quot;: &quot;bar&quot;}]])
data.foo  -- &quot;bar&quot;
</code></pre></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="./js/jquery-1.10.2.min.js"></script>
    <script src="./js/bootstrap-3.0.3.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '.';
    </script>
    <script data-main="./mkdocs/js/search.js" src="./mkdocs/js/require.js"></script>
    <script src="./js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>

<!--
MkDocs version : 0.16.1
Build Date UTC : 2017-01-06 17:59:45
-->
