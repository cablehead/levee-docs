{
    "docs": [
        {
            "location": "/", 
            "text": "require(\"levee\")._\n\n\n_\n is for utilities\n\n\nNetwork\n\n\n\n\n_.endpoint_in(host, port)\n\n\nReturns \nep\n an IPV4 \nEndpoint\n for the given \nhost\n and \nport\n.\n\n\n_.sendto(no, who, buf, len)\n\n\nSends \nbuf\n, \nlen\n over file descriptor \nno\n to \nEndpoint\n \nwho\n. Returns\n  \nerr\n, \nn\n, where \nn\n is the number of characters sent on success.\n\n\n_.recvfrom(no, buf, len)\n\n\nReceives from file descriptor \nno\n into \nbuf\n, \nlen\n. Returns \nerr\n, \nwho\n,\n  \nn\n where \nwho\n is an \nEndpoint\n object of the sender and \nn\n is\n  the number of bytes received.\n\n\n\n\nFile System\n\n\n\n\n_.stat(path)\n\n\nReturns \nerr\n, \nstatinfo\n for the file pointed to by path where \nstatinfo\n is\n  a \nStat\n object.\n\n\n\n\nStat\n\n\n\n\nstat:is_reg()\n\n\nReturns \ntrue\n if this is a regular file.\n\n\nstat:is_dir()\n\n\nReturns \ntrue\n if this is a directory.\n\n\n\n\nrequire(\"levee\").d\n\n\nd\n is for data structure thingies\n\n\nd.Buffer\n\n\nA \nBuffer\n is designed to be a reusable scratch pad of memory. It can grow\ndynamically if it's initial sizing is too small, but eventually you usually\nwant the size of the buffer to reach a steady state. It's the work horse data\nstructure of the Levee library. It is used, for example, to create streaming\nprotocol parsers. The parser reads bytes into the \nBuffer\n until the next token\nin the protocol is reached and the parser can then yield the next portion of\nthe protocol and then \n:trim\n the \nBuffer\n to reset the memory allocation for\nreuse.\n\n\n\n\nd.Buffer([bytes])\n\n\nallocates and returns a new \nbuf\n. \nbytes\n is a sizing hint for the initial\n  allocation of memory for this \nBuffer\n\n\nbuf:ensure([bytes])\n\n\nensures the \nBuffer\n has \nat least\n \nbytes\n available of allocated space, in\n  addition to what's currently in use.\n\n\nbuf:value()\n\n\nreturns \nchar*\n, \nlen\n of the current contents of the \nBuffer\n\n\nbuf:tail()\n\n\nreturns \nchar*\n, \nlen\n to the tail of the allocated \nBuffer\n that's not\n  currently in use.\n\n\nbuf:bumps([len])\n\n\nmoves the marker for in use bytes by \nlen\n\n\nbuf:trim([len])\n\n\nmarks \nlen\n bytes of the \nBuffer\n as available for reuse. If \nlen\n is not\n  supplied to entire \nBuffer\n is marked. Returns \nn\n, the number of bytes\n  trimmed.\n\n\n\n\nlocal buf = d.Buffer()\n\nbuf:ensure(3)\n\nffi.copy(buf:tail(), \nfoo\n)\nbuf:bump(3)\nffi.string(buf:value())  -- \nfoo\n\n\nbuf:trim()\nffi.string(buf:value())  -- \n\n\n\n\n\nrequire(\"levee\").p\n\n\np\n is for parsing / protocol jobbies\n\n\np.json\n\n\n\n\np.json.decode(buf, len)\n\n\nDecode the JSON compliant string \nbuf\n, \nlen\n. \nbuf\n can be a Lua string.\n  Returns \nerr\n, \ndata\n.\n\n\n\n\nlocal p = require(\nlevee\n).p\n\nlocal err, data = p.json.decode([[{\nfoo\n: \nbar\n}]])\ndata.foo  -- \nbar\n\n\n\n\n\nObjects: IO\n\n\nio.R\n\n\n\n\nr:read(buf, len)\n\n\nReads up to \nlen\n bytes into \nbuf\n. Returns \nerr\n, \nn\n where \nn\n is the\n  number of bytes actually read\n\n\nr:readn(buf, n, [len])\n\n\nReads \nat least\n \nn\n bytes into \nbuf\n, but \nno more\n then \nlen\n. \nlen\n\n  defaults to \nn\n. Returns \nerr\n, \nn\n where \nn\n is the number of bytes actually\n  read\n\n\nr:stream()\n\n\nReturns an \nio.Stream\n\n\n\n\nio.W\n\n\n\n\nw:write(buf, len)\n\n\nWrites \nlen\n bytes of \nbuf\n. Returns \nerr\n.\n\n\n\n\nio.Stream\n\n\nA stream is a combination of an \nio.R\n and a \nd.Buffer\n.\n\n\n\n\nstream:readin(n)\n\n\nReads additional bytes into this stream's buffer. \nn\n is optional. If\n  supplied this call will block until \nat least\n \nn\n bytes are available in the\n  buffer. If that many bytes are already available, it will return immediately.\n  If \nn\n is not supplied this call will block until one successful read has\n  been made.\n\n\n\n\nCore: Hub\n\n\nCoroutines\n\n\n\n\nh:sleep(ms)\n\n\nSuspends the current green thread until at least \nms\n milliseconds in the\n  future, when it will be resumed.\n\n\nh:spawn(f)\n\n\nSpawns and queues to run the callable \nf\n as a new green thread. The current\n  thread will yield to be resumed after 1 tick of the event loop.\n\n\nh:spawn_later(ms, f)\n\n\nSchedules the callable \nf\n to run at least \nms\n milliseconds in the future,\n  in a new green thread.\n\n\n\n\nlocal h = require(\nlevee\n).Hub()\n\nh:spawn(function()\n  while true do\n    print(\ntick\n)\n    h:sleep(1000)\n  end\nend)\n\nh:sleep(500)\n\nwhile true do\n  print(\ntock\n)\n  h:sleep(1000)\nend\n\n\n\n\nIO\n\n\n\n\nh.io:stdin()\n\n\nReturns an \nio.R\n object to work with this processes stdin\n\n\n\n\nlocal h = require(\nlevee\n).Hub()\n\nlocal stdin = h.io:stdio()\nlocal stream = stdin:stream()\n\nwhile true do\n  local err, line = stream:line()\n  if err then break end\n  print(line)\nend\n\n\n\n\n\n\nh.io:stdout()\n\n\nReturns an \nio.W\n object to work with this processes stdout\n\n\n\n\nNetwork\n\n\n\n\nh.stream:dial(port, [host])\n\n\nEstablishes a streamed network connection with \nport\n and \nhost\n. \nhost\n\n  defaults to \nlocalhost\n. Returns \nerr\n, \nio.RW", 
            "title": "Home"
        }, 
        {
            "location": "/#requirelevee95", 
            "text": "_  is for utilities", 
            "title": "require(\"levee\")._"
        }, 
        {
            "location": "/#network", 
            "text": "_.endpoint_in(host, port)  Returns  ep  an IPV4  Endpoint  for the given  host  and  port .  _.sendto(no, who, buf, len)  Sends  buf ,  len  over file descriptor  no  to  Endpoint   who . Returns\n   err ,  n , where  n  is the number of characters sent on success.  _.recvfrom(no, buf, len)  Receives from file descriptor  no  into  buf ,  len . Returns  err ,  who ,\n   n  where  who  is an  Endpoint  object of the sender and  n  is\n  the number of bytes received.", 
            "title": "Network"
        }, 
        {
            "location": "/#file-system", 
            "text": "_.stat(path)  Returns  err ,  statinfo  for the file pointed to by path where  statinfo  is\n  a  Stat  object.", 
            "title": "File System"
        }, 
        {
            "location": "/#stat", 
            "text": "stat:is_reg()  Returns  true  if this is a regular file.  stat:is_dir()  Returns  true  if this is a directory.", 
            "title": "Stat"
        }, 
        {
            "location": "/#requireleveed", 
            "text": "d  is for data structure thingies", 
            "title": "require(\"levee\").d"
        }, 
        {
            "location": "/#dbuffer", 
            "text": "A  Buffer  is designed to be a reusable scratch pad of memory. It can grow\ndynamically if it's initial sizing is too small, but eventually you usually\nwant the size of the buffer to reach a steady state. It's the work horse data\nstructure of the Levee library. It is used, for example, to create streaming\nprotocol parsers. The parser reads bytes into the  Buffer  until the next token\nin the protocol is reached and the parser can then yield the next portion of\nthe protocol and then  :trim  the  Buffer  to reset the memory allocation for\nreuse.   d.Buffer([bytes])  allocates and returns a new  buf .  bytes  is a sizing hint for the initial\n  allocation of memory for this  Buffer  buf:ensure([bytes])  ensures the  Buffer  has  at least   bytes  available of allocated space, in\n  addition to what's currently in use.  buf:value()  returns  char* ,  len  of the current contents of the  Buffer  buf:tail()  returns  char* ,  len  to the tail of the allocated  Buffer  that's not\n  currently in use.  buf:bumps([len])  moves the marker for in use bytes by  len  buf:trim([len])  marks  len  bytes of the  Buffer  as available for reuse. If  len  is not\n  supplied to entire  Buffer  is marked. Returns  n , the number of bytes\n  trimmed.   local buf = d.Buffer()\n\nbuf:ensure(3)\n\nffi.copy(buf:tail(),  foo )\nbuf:bump(3)\nffi.string(buf:value())  --  foo \n\nbuf:trim()\nffi.string(buf:value())  --", 
            "title": "d.Buffer"
        }, 
        {
            "location": "/#requireleveep", 
            "text": "p  is for parsing / protocol jobbies", 
            "title": "require(\"levee\").p"
        }, 
        {
            "location": "/#pjson", 
            "text": "p.json.decode(buf, len)  Decode the JSON compliant string  buf ,  len .  buf  can be a Lua string.\n  Returns  err ,  data .   local p = require( levee ).p\n\nlocal err, data = p.json.decode([[{ foo :  bar }]])\ndata.foo  --  bar", 
            "title": "p.json"
        }, 
        {
            "location": "/#objects-io", 
            "text": "", 
            "title": "Objects: IO"
        }, 
        {
            "location": "/#ior", 
            "text": "r:read(buf, len)  Reads up to  len  bytes into  buf . Returns  err ,  n  where  n  is the\n  number of bytes actually read  r:readn(buf, n, [len])  Reads  at least   n  bytes into  buf , but  no more  then  len .  len \n  defaults to  n . Returns  err ,  n  where  n  is the number of bytes actually\n  read  r:stream()  Returns an  io.Stream", 
            "title": "io.R"
        }, 
        {
            "location": "/#iow", 
            "text": "w:write(buf, len)  Writes  len  bytes of  buf . Returns  err .", 
            "title": "io.W"
        }, 
        {
            "location": "/#iostream", 
            "text": "A stream is a combination of an  io.R  and a  d.Buffer .   stream:readin(n)  Reads additional bytes into this stream's buffer.  n  is optional. If\n  supplied this call will block until  at least   n  bytes are available in the\n  buffer. If that many bytes are already available, it will return immediately.\n  If  n  is not supplied this call will block until one successful read has\n  been made.", 
            "title": "io.Stream"
        }, 
        {
            "location": "/#core-hub", 
            "text": "", 
            "title": "Core: Hub"
        }, 
        {
            "location": "/#coroutines", 
            "text": "h:sleep(ms)  Suspends the current green thread until at least  ms  milliseconds in the\n  future, when it will be resumed.  h:spawn(f)  Spawns and queues to run the callable  f  as a new green thread. The current\n  thread will yield to be resumed after 1 tick of the event loop.  h:spawn_later(ms, f)  Schedules the callable  f  to run at least  ms  milliseconds in the future,\n  in a new green thread.   local h = require( levee ).Hub()\n\nh:spawn(function()\n  while true do\n    print( tick )\n    h:sleep(1000)\n  end\nend)\n\nh:sleep(500)\n\nwhile true do\n  print( tock )\n  h:sleep(1000)\nend", 
            "title": "Coroutines"
        }, 
        {
            "location": "/#io", 
            "text": "h.io:stdin()  Returns an  io.R  object to work with this processes stdin   local h = require( levee ).Hub()\n\nlocal stdin = h.io:stdio()\nlocal stream = stdin:stream()\n\nwhile true do\n  local err, line = stream:line()\n  if err then break end\n  print(line)\nend   h.io:stdout()  Returns an  io.W  object to work with this processes stdout", 
            "title": "IO"
        }, 
        {
            "location": "/#network_1", 
            "text": "h.stream:dial(port, [host])  Establishes a streamed network connection with  port  and  host .  host \n  defaults to  localhost . Returns  err ,  io.RW", 
            "title": "Network"
        }
    ]
}