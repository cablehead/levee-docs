{
    "docs": [
        {
            "location": "/", 
            "text": "Core: Hub\n\n\nCoroutines\n\n\n\n\nh:sleep(ms)\n\n\nSuspends the current green thread until at least \nms\n milliseconds in the\n  future, when it will be resumed.\n\n\nh:spawn(f)\n\n\nSpawns and queues to run the callable \nf\n as a new green thread. The current\n  thread will yield to be resumed after 1 tick of the event loop.\n\n\nh:spawn_later(ms, f)\n\n\nSchedules the callable \nf\n to run at least \nms\n milliseconds in the future,\n  in a new green thread.\n\n\n\n\nlocal h = require(\nlevee\n).Hub()\n\nh:spawn(function()\n  while true do\n    print(\ntick\n)\n    h:sleep(1000)\n  end\nend)\n\nh:sleep(500)\n\nwhile true do\n  print(\ntock\n)\n  h:sleep(1000)\nend\n\n\n\n\nIO\n\n\n\n\nh.io:stdin()\n\n\nReturns an \nio.R\n object to work with this processes stdin\n\n\n\n\nlocal h = require(\nlevee\n).Hub()\n\nlocal stdin = h.io:stdio()\nlocal stream = stdin:stream()\n\nwhile true do\n  local err, line = stream:line()\n  if err then break end\n  print(line)\nend\n\n\n\n\n\n\nh.io:stdout()\n\n\nReturns an \nio.W\n object to work with this processes stdout\n\n\n\n\nNetwork\n\n\n\n\nh.stream:dial(endpoint|options)\n\n\nEstablishes a streamed network connection based on the supplied \nendpoint\n\n  string or \noptions\n (\nendpoint\n TBD). Returns \nerr\n, \nio.RW\n\n\n\n\nOptions are:\n\n\n\n\n\n\nlocal\n: path to unix domain socket (TBD) \nOR\n\n\n\n\n\n\nport\n: port to connect to\n\n\n\n\n\n\nhost\n: host to connect to (default: localhost)\n\n\n\n\n\n\ntimeout\n: timeout for reads and writes on this connection\n\n\n\n\n\n\nconnect_timeout\n: timeout to apply to connection\n\n\n\n\n\n\ntls\n: upgrade this connection to use tls. Note \ntimeout\n also applies to the\n  tls handshake. The value is a table of \nTLS Options\n.\n\n\n\n\n\n\n\n\nh.stream:listen(endpoint|options)\n\n\nBinds to \nendpoint\n string or as specified with \noptions\n and listens for\n  streamed connections. Returns \nerr\n, \nRecver\n. The Recver yields \nerr\n,\n  \nio.RW\n for each accepted connection.\n\n\n\n\nOptions are:\n\n\n\n\n\n\nlocal\n: path to unix domain socket (TBD) \nOR\n\n\n\n\n\n\nport\n: port to bind to (default: 0)\n\n\n\n\n\n\nhost\n: host to bind to (default: localhost)\n\n\n\n\n\n\nbacklog\n: the maximum length for the queue of pending connections (default:\n  256)\n\n\n\n\n\n\ntimeout\n: sets the read / write timeout for accepted connections\n\n\n\n\n\n\ntls\n: upgrade accepted connections to use tls. Note \ntimeout\n also\n  applies to the tls handshake. The value is a table of \nTLS\n  Options\n.\n\n\n\n\n\n\nlocal h = require(\nlevee\n).Hub()\n\n-- a basic echo server\nlocal err, serve = h.stream:listen({port=9000})\n\nwhile true do\n    local err, conn = serve:recv()\n    if err then break end\n    h:spawn(function()\n        local buf = levee.d.Buffer(4096)\n        conn:readinto(buf:tail())\n        conn:write(buf:value())\n        conn:close()\n    end)\nend\n\n\n\n\nHTTP\n\n\n\n\nh.http:dial([endpoint|host], options)\n\n\nendpoint|host\n is a string. Returns \nerr\n, \nHTTP.Client\n\n\n\n\nOptions are:\n\n\n\n\n\n\nlocal\n: path to unix domain socket (TBD) \nOR\n\n\n\n\n\n\nport\n: port to connect to\n\n\n\n\n\n\nhost\n: host to connect to (default: localhost)\n\n\n\n\n\n\ntimeout\n: timeout for reads and writes on this connection\n\n\n\n\n\n\nconnect_timeout\n: timeout to apply to connection\n\n\n\n\n\n\ntls\n: upgrade this connection to use tls. Note \ntimeout\n also applies to the\n  tls handshake. The value is a table of \nTLS Options\n.\n\n\n\n\n\n\n\n\nh.http:listen(endpoint|options)\n\n\nBinds to \nendpoint\n string or as specified with \noptions\n and listens for\n  streamed connections. Returns \nerr\n, \nRecver\n. The Recver yields \nerr\n,\n  \nHTTP.Server\n for each accepted connection.\n\n\n\n\nOptions are:\n\n\n\n\n\n\nlocal\n: path to unix domain socket (TBD) \nOR\n\n\n\n\n\n\nport\n: port to bind to (default: 0)\n\n\n\n\n\n\nhost\n: host to bind to (default: localhost)\n\n\n\n\n\n\nbacklog\n: the maximum length for the queue of pending connections (default:\n  256)\n\n\n\n\n\n\ntimeout\n: sets the read / write timeout for accepted connections\n\n\n\n\n\n\ntls\n: upgrade accepted connections to use tls. Note \ntimeout\n also\n  applies to the tls handshake. The value is a table of \nTLS\n  Options\n.\n\n\n\n\n\n\nObjects: IO\n\n\nio.R\n\n\n\n\nr:read(char*, len)\n\n\nReads up to \nlen\n bytes into \nchar*\n. Returns \nerr\n, \nn\n where \nn\n is the\n  number of bytes actually read\n\n\nr:readn(char*, n, [len])\n\n\nReads \nat least\n \nn\n bytes into \nchar*\n, but \nno more\n then \nlen\n. \nlen\n\n  defaults to \nn\n. Returns \nerr\n, \nn\n where \nn\n is the number of bytes actually\n  read\n\n\nr:readinto(buf, n)\n\n\nReads \nat least\n \nn\n bytes into \nbuf\n. Handles ensuring the \nbuf\n\n  is large enough to accommodate \nn\n and bumps the contents marker. Returns\n  \nerr\n.\n\n\nr:stream()\n\n\nReturns an \nio.Stream\n\n\n\n\nio.W\n\n\n\n\nw:write(buf, [len])\n\n\nWrites \nbuf\n. \nbuf\n can either be a \nchar *\n or a \nstring\n. \nlen\n defaults to\n  \n#buf\n.  Returns \nerr\n.\n\n\n\n\nio.Stream\n\n\nA stream is a combination of an \nio.R\n and a \nd.Buffer\n.\n\n\n\n\nstream:readin([n])\n\n\nReads additional bytes into this stream's buffer. \nn\n is optional. If\n  supplied this call will block until \nat least\n \nn\n bytes are available in the\n  buffer. If that many bytes are already available, it will return immediately.\n  If \nn\n is not supplied this call will block until one successful read has\n  been made.\n\n\n\n\nObjects: HTTP\n\n\nHTTP.Client\n\n\nHTTP.Server\n\n\nMisc: TLS Options\n\n\n  Certificate Authority:\n    ca = BYTES            # root certificates from string\n    ca_path = DIRECTORY   # directory searched for root certificates\n    ca_file = FILE        # file containing the root certificates\n  Certificate:\n    cert = BYTES          # public certificate from string\n    cert_file = FILE      # file containing the public certificate\n  Key:\n    key = BYTES           # private key from string\n    key_file = FILE       # file containing the private key\n  Ciphers:\n    ciphers = \nsecure\n    # use the secure ciphers only (default)\n    ciphers = \ncompat\n    # OpenSSL compatibility\n    ciphers = \nlegacy\n    # (not documented)\n    ciphers = \ninsecure\n  # all ciphers available\n    ciphers = \nall\n       # same as \ninsecure\n\n    ciphers = STRING      # see CIPHERS section of openssl(1)\n  DHE Params:\n    dheparams = STRING    # (not documented)\n  ECDHE Curve:\n    ecdhecurve = STRING   # (not documented)\n  Protocols:\n    protocols = \nTLSv1.0\n # only TLSv1.0\n    protocols = \nTLSv1.1\n # only TLSv1.1\n    protocols = \nTLSv1.2\n # only TLSv1.2\n    protocols = \nALL\n     # all supported protocols\n    protocols = \nDEFAULT\n # currently TLSv1.2\n    protocols = LIST      # any combination of the above strings\n  Verfiy Depth:\n    verify_depth = NUMBER # limit verification depth (?)\n  Server:\n    server = {\n      prefer_ciphers = \nserver\n  # prefer client cipher list (less secure)\n      prefer_ciphers = \nclient\n  # prefer server cipher list (more secure, default)\n      verify_client = true       # require client to send certificate\n      verify_client = \noptional\n # enable client to send certificate\n    }\n  Insecure:\n    insecure = {\n      verify_cert = false        # disable certificate verification\n      verify_name = false        # disable server name verification for client\n      verify_time = false        # disable validity checking of certificates\n    }\n\n\n\n\nrequire(\"levee\")._\n\n\n_\n is for utilities\n\n\nNetwork\n\n\n\n\n_.endpoint_in(host, port)\n\n\nReturns \nep\n an IPV4 \nEndpoint\n for the given \nhost\n and \nport\n.\n\n\n_.sendto(no, who, buf, len)\n\n\nSends \nbuf\n, \nlen\n over file descriptor \nno\n to \nEndpoint\n \nwho\n. Returns\n  \nerr\n, \nn\n, where \nn\n is the number of characters sent on success.\n\n\n_.recvfrom(no, buf, len)\n\n\nReceives from file descriptor \nno\n into \nbuf\n, \nlen\n. Returns \nerr\n, \nwho\n,\n  \nn\n where \nwho\n is an \nEndpoint\n object of the sender and \nn\n is\n  the number of bytes received.\n\n\n\n\nFile System\n\n\n\n\n_.stat(path)\n\n\nReturns \nerr\n, \nstatinfo\n for the file pointed to by path where \nstatinfo\n is\n  a \nStat\n object.\n\n\n\n\nStat\n\n\n\n\nstat:is_reg()\n\n\nReturns \ntrue\n if this is a regular file.\n\n\nstat:is_dir()\n\n\nReturns \ntrue\n if this is a directory.\n\n\n\n\nrequire(\"levee\").d\n\n\nd\n is for data structure thingies\n\n\nd.Buffer\n\n\nA \nBuffer\n is designed to be a reusable scratch pad of memory. It can grow\ndynamically if it's initial sizing is too small, but eventually you usually\nwant the size of the buffer to reach a steady state. It's the work horse data\nstructure of the Levee library. It is used, for example, to create streaming\nprotocol parsers. The parser reads bytes into the \nBuffer\n until the next token\nin the protocol is reached and the parser can then yield the next portion of\nthe protocol and then \n:trim\n the \nBuffer\n to reset the memory allocation for\nreuse.\n\n\n\n\nd.Buffer([bytes])\n\n\nallocates and returns a new \nbuf\n. \nbytes\n is a sizing hint for the initial\n  allocation of memory for this \nBuffer\n\n\nbuf:ensure([bytes])\n\n\nensures the \nBuffer\n has \nat least\n \nbytes\n available of allocated space, in\n  addition to what's currently in use.\n\n\nbuf:write(buf, [len])\n\n\ncopies \nbuf\n into the tail of the \nBuffer\n. \nbuf\n can either be a \nchar *\n or a\n  \nstring\n. \nlen\n defaults to \n#buf\n. Write ensures the buffer is large enough to\n  hold the write and bumps the \nBuffer\n's content marker\n\n\nbuf:value([[off], len])\n\n\nIf \nlen\n is supplied it should be less than the current length of the\n  \nBuffer\n. \nlen\n defaults to the entire \nBuffer\n's contents. The optional\n  \noff\n offsets the returned \nchar *\n from the beginning of the \nBuffer\n's\n  contents.  Returns \nchar*\n, \nlen\n\n\nbuf:tail()\n\n\nreturns \nchar*\n, \nlen\n to the tail of the allocated \nBuffer\n that's not\n  currently in use\n\n\nbuf:bump(len)\n\n\nmoves the marker for in use bytes by \nlen\n\n\nbuf:trim([len])\n\n\nmarks \nlen\n bytes of the \nBuffer\n as available for reuse. If \nlen\n is not\n  supplied to entire \nBuffer\n is marked. Returns \nn\n, the number of bytes\n  trimmed\n\n\n\n\nlocal buf = d.Buffer()\n\nbuf:ensure(3)\nffi.copy(buf:tail(), \nfoo\n)\nbuf:bump(3)\nffi.string(buf:value())  -- \nfoo\n\n\nbuf:write(\nbar\n)\nffi.string(buf:value())  -- \nfoobar\n\n\nffi.string(buf:value(3))  -- \nfoo\n\nffi.string(buf:value(3, 1))  -- \nb\n\n\nbuf:trim()\nffi.string(buf:value())  -- \n\n\n\n\n\nd.Iovec\n\n\n\n\nd.Iovec([size])\n\n\ntodo\n\n\n\n\nrequire(\"levee\").p\n\n\np\n is for parsing / protocol jobbies\n\n\np.json\n\n\n\n\np.json.decode(buf, len)\n\n\nDecode the JSON compliant string \nbuf\n, \nlen\n. \nbuf\n can be a Lua string.\n  Returns \nerr\n, \ndata\n.\n\n\n\n\nlocal p = require(\nlevee\n).p\n\nlocal err, data = p.json.decode([[{\nfoo\n: \nbar\n}]])\ndata.foo  -- \nbar", 
            "title": "Home"
        }, 
        {
            "location": "/#core-hub", 
            "text": "", 
            "title": "Core: Hub"
        }, 
        {
            "location": "/#coroutines", 
            "text": "h:sleep(ms)  Suspends the current green thread until at least  ms  milliseconds in the\n  future, when it will be resumed.  h:spawn(f)  Spawns and queues to run the callable  f  as a new green thread. The current\n  thread will yield to be resumed after 1 tick of the event loop.  h:spawn_later(ms, f)  Schedules the callable  f  to run at least  ms  milliseconds in the future,\n  in a new green thread.   local h = require( levee ).Hub()\n\nh:spawn(function()\n  while true do\n    print( tick )\n    h:sleep(1000)\n  end\nend)\n\nh:sleep(500)\n\nwhile true do\n  print( tock )\n  h:sleep(1000)\nend", 
            "title": "Coroutines"
        }, 
        {
            "location": "/#io", 
            "text": "h.io:stdin()  Returns an  io.R  object to work with this processes stdin   local h = require( levee ).Hub()\n\nlocal stdin = h.io:stdio()\nlocal stream = stdin:stream()\n\nwhile true do\n  local err, line = stream:line()\n  if err then break end\n  print(line)\nend   h.io:stdout()  Returns an  io.W  object to work with this processes stdout", 
            "title": "IO"
        }, 
        {
            "location": "/#network", 
            "text": "h.stream:dial(endpoint|options)  Establishes a streamed network connection based on the supplied  endpoint \n  string or  options  ( endpoint  TBD). Returns  err ,  io.RW   Options are:    local : path to unix domain socket (TBD)  OR    port : port to connect to    host : host to connect to (default: localhost)    timeout : timeout for reads and writes on this connection    connect_timeout : timeout to apply to connection    tls : upgrade this connection to use tls. Note  timeout  also applies to the\n  tls handshake. The value is a table of  TLS Options .     h.stream:listen(endpoint|options)  Binds to  endpoint  string or as specified with  options  and listens for\n  streamed connections. Returns  err ,  Recver . The Recver yields  err ,\n   io.RW  for each accepted connection.   Options are:    local : path to unix domain socket (TBD)  OR    port : port to bind to (default: 0)    host : host to bind to (default: localhost)    backlog : the maximum length for the queue of pending connections (default:\n  256)    timeout : sets the read / write timeout for accepted connections    tls : upgrade accepted connections to use tls. Note  timeout  also\n  applies to the tls handshake. The value is a table of  TLS\n  Options .    local h = require( levee ).Hub()\n\n-- a basic echo server\nlocal err, serve = h.stream:listen({port=9000})\n\nwhile true do\n    local err, conn = serve:recv()\n    if err then break end\n    h:spawn(function()\n        local buf = levee.d.Buffer(4096)\n        conn:readinto(buf:tail())\n        conn:write(buf:value())\n        conn:close()\n    end)\nend", 
            "title": "Network"
        }, 
        {
            "location": "/#http", 
            "text": "h.http:dial([endpoint|host], options)  endpoint|host  is a string. Returns  err ,  HTTP.Client   Options are:    local : path to unix domain socket (TBD)  OR    port : port to connect to    host : host to connect to (default: localhost)    timeout : timeout for reads and writes on this connection    connect_timeout : timeout to apply to connection    tls : upgrade this connection to use tls. Note  timeout  also applies to the\n  tls handshake. The value is a table of  TLS Options .     h.http:listen(endpoint|options)  Binds to  endpoint  string or as specified with  options  and listens for\n  streamed connections. Returns  err ,  Recver . The Recver yields  err ,\n   HTTP.Server  for each accepted connection.   Options are:    local : path to unix domain socket (TBD)  OR    port : port to bind to (default: 0)    host : host to bind to (default: localhost)    backlog : the maximum length for the queue of pending connections (default:\n  256)    timeout : sets the read / write timeout for accepted connections    tls : upgrade accepted connections to use tls. Note  timeout  also\n  applies to the tls handshake. The value is a table of  TLS\n  Options .", 
            "title": "HTTP"
        }, 
        {
            "location": "/#objects-io", 
            "text": "", 
            "title": "Objects: IO"
        }, 
        {
            "location": "/#ior", 
            "text": "r:read(char*, len)  Reads up to  len  bytes into  char* . Returns  err ,  n  where  n  is the\n  number of bytes actually read  r:readn(char*, n, [len])  Reads  at least   n  bytes into  char* , but  no more  then  len .  len \n  defaults to  n . Returns  err ,  n  where  n  is the number of bytes actually\n  read  r:readinto(buf, n)  Reads  at least   n  bytes into  buf . Handles ensuring the  buf \n  is large enough to accommodate  n  and bumps the contents marker. Returns\n   err .  r:stream()  Returns an  io.Stream", 
            "title": "io.R"
        }, 
        {
            "location": "/#iow", 
            "text": "w:write(buf, [len])  Writes  buf .  buf  can either be a  char *  or a  string .  len  defaults to\n   #buf .  Returns  err .", 
            "title": "io.W"
        }, 
        {
            "location": "/#iostream", 
            "text": "A stream is a combination of an  io.R  and a  d.Buffer .   stream:readin([n])  Reads additional bytes into this stream's buffer.  n  is optional. If\n  supplied this call will block until  at least   n  bytes are available in the\n  buffer. If that many bytes are already available, it will return immediately.\n  If  n  is not supplied this call will block until one successful read has\n  been made.", 
            "title": "io.Stream"
        }, 
        {
            "location": "/#objects-http", 
            "text": "", 
            "title": "Objects: HTTP"
        }, 
        {
            "location": "/#httpclient", 
            "text": "", 
            "title": "HTTP.Client"
        }, 
        {
            "location": "/#httpserver", 
            "text": "", 
            "title": "HTTP.Server"
        }, 
        {
            "location": "/#misc-tls-options", 
            "text": "Certificate Authority:\n    ca = BYTES            # root certificates from string\n    ca_path = DIRECTORY   # directory searched for root certificates\n    ca_file = FILE        # file containing the root certificates\n  Certificate:\n    cert = BYTES          # public certificate from string\n    cert_file = FILE      # file containing the public certificate\n  Key:\n    key = BYTES           # private key from string\n    key_file = FILE       # file containing the private key\n  Ciphers:\n    ciphers =  secure     # use the secure ciphers only (default)\n    ciphers =  compat     # OpenSSL compatibility\n    ciphers =  legacy     # (not documented)\n    ciphers =  insecure   # all ciphers available\n    ciphers =  all        # same as  insecure \n    ciphers = STRING      # see CIPHERS section of openssl(1)\n  DHE Params:\n    dheparams = STRING    # (not documented)\n  ECDHE Curve:\n    ecdhecurve = STRING   # (not documented)\n  Protocols:\n    protocols =  TLSv1.0  # only TLSv1.0\n    protocols =  TLSv1.1  # only TLSv1.1\n    protocols =  TLSv1.2  # only TLSv1.2\n    protocols =  ALL      # all supported protocols\n    protocols =  DEFAULT  # currently TLSv1.2\n    protocols = LIST      # any combination of the above strings\n  Verfiy Depth:\n    verify_depth = NUMBER # limit verification depth (?)\n  Server:\n    server = {\n      prefer_ciphers =  server   # prefer client cipher list (less secure)\n      prefer_ciphers =  client   # prefer server cipher list (more secure, default)\n      verify_client = true       # require client to send certificate\n      verify_client =  optional  # enable client to send certificate\n    }\n  Insecure:\n    insecure = {\n      verify_cert = false        # disable certificate verification\n      verify_name = false        # disable server name verification for client\n      verify_time = false        # disable validity checking of certificates\n    }", 
            "title": "Misc: TLS Options"
        }, 
        {
            "location": "/#requirelevee95", 
            "text": "_  is for utilities", 
            "title": "require(\"levee\")._"
        }, 
        {
            "location": "/#network_1", 
            "text": "_.endpoint_in(host, port)  Returns  ep  an IPV4  Endpoint  for the given  host  and  port .  _.sendto(no, who, buf, len)  Sends  buf ,  len  over file descriptor  no  to  Endpoint   who . Returns\n   err ,  n , where  n  is the number of characters sent on success.  _.recvfrom(no, buf, len)  Receives from file descriptor  no  into  buf ,  len . Returns  err ,  who ,\n   n  where  who  is an  Endpoint  object of the sender and  n  is\n  the number of bytes received.", 
            "title": "Network"
        }, 
        {
            "location": "/#file-system", 
            "text": "_.stat(path)  Returns  err ,  statinfo  for the file pointed to by path where  statinfo  is\n  a  Stat  object.", 
            "title": "File System"
        }, 
        {
            "location": "/#stat", 
            "text": "stat:is_reg()  Returns  true  if this is a regular file.  stat:is_dir()  Returns  true  if this is a directory.", 
            "title": "Stat"
        }, 
        {
            "location": "/#requireleveed", 
            "text": "d  is for data structure thingies", 
            "title": "require(\"levee\").d"
        }, 
        {
            "location": "/#dbuffer", 
            "text": "A  Buffer  is designed to be a reusable scratch pad of memory. It can grow\ndynamically if it's initial sizing is too small, but eventually you usually\nwant the size of the buffer to reach a steady state. It's the work horse data\nstructure of the Levee library. It is used, for example, to create streaming\nprotocol parsers. The parser reads bytes into the  Buffer  until the next token\nin the protocol is reached and the parser can then yield the next portion of\nthe protocol and then  :trim  the  Buffer  to reset the memory allocation for\nreuse.   d.Buffer([bytes])  allocates and returns a new  buf .  bytes  is a sizing hint for the initial\n  allocation of memory for this  Buffer  buf:ensure([bytes])  ensures the  Buffer  has  at least   bytes  available of allocated space, in\n  addition to what's currently in use.  buf:write(buf, [len])  copies  buf  into the tail of the  Buffer .  buf  can either be a  char *  or a\n   string .  len  defaults to  #buf . Write ensures the buffer is large enough to\n  hold the write and bumps the  Buffer 's content marker  buf:value([[off], len])  If  len  is supplied it should be less than the current length of the\n   Buffer .  len  defaults to the entire  Buffer 's contents. The optional\n   off  offsets the returned  char *  from the beginning of the  Buffer 's\n  contents.  Returns  char* ,  len  buf:tail()  returns  char* ,  len  to the tail of the allocated  Buffer  that's not\n  currently in use  buf:bump(len)  moves the marker for in use bytes by  len  buf:trim([len])  marks  len  bytes of the  Buffer  as available for reuse. If  len  is not\n  supplied to entire  Buffer  is marked. Returns  n , the number of bytes\n  trimmed   local buf = d.Buffer()\n\nbuf:ensure(3)\nffi.copy(buf:tail(),  foo )\nbuf:bump(3)\nffi.string(buf:value())  --  foo \n\nbuf:write( bar )\nffi.string(buf:value())  --  foobar \n\nffi.string(buf:value(3))  --  foo \nffi.string(buf:value(3, 1))  --  b \n\nbuf:trim()\nffi.string(buf:value())  --", 
            "title": "d.Buffer"
        }, 
        {
            "location": "/#diovec", 
            "text": "d.Iovec([size])  todo", 
            "title": "d.Iovec"
        }, 
        {
            "location": "/#requireleveep", 
            "text": "p  is for parsing / protocol jobbies", 
            "title": "require(\"levee\").p"
        }, 
        {
            "location": "/#pjson", 
            "text": "p.json.decode(buf, len)  Decode the JSON compliant string  buf ,  len .  buf  can be a Lua string.\n  Returns  err ,  data .   local p = require( levee ).p\n\nlocal err, data = p.json.decode([[{ foo :  bar }]])\ndata.foo  --  bar", 
            "title": "p.json"
        }
    ]
}